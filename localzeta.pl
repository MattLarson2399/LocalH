#!/usr/bin/perl
#Contributors: Matt Larson
#Last updated: 08/30/2020

#computes the topological local zeta function associated to a Newton polyhedron

use strict;
use warnings;
use application "polytope";
use Algorithm::Combinatorics "subsets";
#use Math::Matrix;

script("/Users/matthew/Desktop/Local_Zeta_Function/code/subs.pl");



#usage: multiplicityArray(AoA)
#computes the multiplicity of an array of r integer vectors
#i.e. computes the index of the lattice generated by the vectors in the group of all lattice points 
#in the vector space spanned by the vectors
#does this by taking the gcd of the determinents of the rxr minors
sub multiplicityArray{
	my @input = @{shift @_};
	my @vecs = map(latticePointToArray($_), @input);
	my $mat = new Matrix<Integer>(\@vecs);
	my $v = pluecker($mat);
	return gcd($v);
}
#usage: newtonPolyhedron($diagram)
#diagram does not need to be reduced
#outputs the newton polyhedron as a polyhedron
sub newtonPolyhedron{
	my $diagram = shift;
	my $proj = toReverseProjectiveArray($diagram);
	my $dim = scalar(@{$diagram->[0]});
	my $verts = standard_simplex_vertices($dim - 1);
	map(unshift($_, 0), @{$verts});
	push(@{$proj}, @{$verts});
	my $Mat=new Matrix<Rational>($proj);
	my $p = new Polytope(POINTS=>$Mat);
	return $p;
}

#usage: dualFan($diagram)
#creates the dual fan by making the newton polyhedron
sub dualFan{
	my $diagram = shift;
	my $newton = newtonPolyhedron($diagram);
	my $fan = fan::normal_fan($newton);
	return $fan;
}

#usage: changeToPrimitive($arref)
#assumes every entry is either 1 or 0 or a non-integer Rational - must use the polymake type
#returns a primitive integer vector in that direction
sub changeToPrimitive{
	my @array = @{shift @_};
	#@array = map(vectorToArray($_), @array);
	my $denom = 1;
	for my $n (@array){
		if (($n == 0) or ($n == 1)){
			next;
		}
		$denom = denominator($n) * $denom;
	}
	my @result;
	for my $n (@array){
		my $a = new Integer($n * $denom);
		push(@result, $a);
	}
	return makePrimitive(\@result);
}

#usage:dotProduct($aref, $aref)
#arefs should be the same length
#computes the dot product
sub dotProduct{
	my $vec1 = shift;
	my $vec2 = shift;
	my $answer = 0;
	for my $i (0..(scalar(@{$vec1}) - 1)){
		$answer += ($vec1->[$i])*($vec2->[$i]);
	}
	return $answer;
}


#usage: computeN($point, $diagram)
#takes a point in the dual fan
#compute the minimimum value of the pairing of that with the newton polyhedron
sub computeN{
	my $point = shift;
	my $diagram = shift;
	my $best = dotProduct($point, $diagram->[0]);
	for my $i (0..(scalar(@{$diagram}) - 1)){
		if ($best > dotProduct($point, $diagram->[$i])){
			$best = dotProduct($point, $diagram->[$i]);
		}
	}
	return $best;
}

#usage: jDelta(arref of points, diagram)
#computes J_{\Delta} for the cone spanned by these points
#points should be primitive, but will make sense if not
sub jDelta{
	my @points = @{shift @_};
	my $diagram = shift;
	my $mult = multiplicityArray(\@points);
	#my $mult = 1;
	my $answer = new UniPolynomial($mult);
	for my $p (@points){
		my $n = computeN($p, $diagram);
		my $v = sumArray($p);
		my $contrib = new UniPolynomial("$n*x + $v");
		$answer = $answer/$contrib
	}
	return $answer;
}

#usage: normalizedVolume($arref of lattice points)
#returns the normalized volume of the convex hull of the vertices
sub normalizedVolume{
	my $vertices = shift;
	my $proj = toReverseProjectiveArray($vertices);
	my $poly = new LatticePolytope(POINTS=>$proj);
	return $poly->LATTICE_VOLUME;

}

#usage: subdivideCone(arref of vertices)
#returns a subdivision of the cone by the convex hull of the vertices 
sub subdivideCone{
	my @rays = @{shift @_};
	my $cone = new Cone(RAYS=>\@rays);
	my $t = $cone->TRIANGULATION;
	my $vectorsubdiv = $t->FACETS;
	my @subdiv = map(vectorToArray($_), @{$vectorsubdiv});
	return \@subdiv;
}

#usage: totalContribution(rays of a cone, diagram)
#subdivides the cone into rational simplicial parts and returns the total contribution
sub totalContribution{
	my $rays = shift;
	my $diagram = shift;
	my $primitive = subdivideCone($rays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		my @subdividedrays = map($rays->[$_], @{$tri});
		my @prim = map(changeToPrimitive($_), @subdividedrays);
		$answer = $answer + jDelta(\@prim, $diagram);
	}
	return $answer;
}


#usage: allCones(Fan)
#returns all cones of the fan
#includes the empty cone
sub allCones{
	my $fan = shift;
	my @cones = @{$fan->MAXIMAL_CONES};
	my @allcones;
	my %hash;	
	for my $cone (@cones){
		my @c = @{$cone};
		my @subcones = subsets(\@c);
		for my $sc (@subcones){
			my $str = "@{$sc}";
			if (not $hash{$str}){
				$hash{$str} = 1;
				push(@allcones, $sc);
			}
		}
	}
	return \@allcones;
}


#usage: allConesByDim($fan)
#returns an Array of Array of Arrays
#first array is the dimension of the cone
#second AoA contains all cones of that dimension
sub allConesByDim{
	my $fan = shift;
	my @cones = @{$fan->CONES};
	my @results;
	for my $i (0..(($fan->DIM) - 1)){
		my @cdims = map(vectorToArray($_), @{$cones[$i]});
		push(@results, \@cdims);
	}
	return \@results;
}

#usage: rayToFacet(ray, diagram, sorted AoA of bounded facets)
#the AoA must be a sorted (by decreasing length) array of the bounded faces of the newton polyhedron 
#facet should be given as a list of vertices in the diagram, diagram should be reduced
#returns the facet corresponding to the array
#does this by looping through the facets, checking if the pairing of ray with all vertices in them is the same
#if it doesn't match any of them then returns -1
sub rayToFacet{
	my @ray = @{shift @_};
	my $diagram = shift;
	my @flist = @{shift @_};
	my $correct = 1;
	my $num = computeN(\@ray, $diagram);
	for my $f (@flist){
		$correct = 1;
		for my $i (0..(scalar(@{$f}) - 1)){
			if ($num != dotProduct(\@ray, $diagram->[$f->[$i]])){
				$correct = 0;
				last;
			}
		}
		if ($correct == 1){
			return $f;
		}

	}
	return -1;
}

#usage: boundedPart(face, diagram)
#returns the maximal bounded face contained in the face
#diagram must be reduced
sub boundedPart{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @new_face;
	for my $v (@face){
		if ($v < $num_verts){
			push(@new_face, $v);
		}
	}
	return \@new_face;
}

#usage: isBounded($face, $diagram)
#returns 1 if the face is bounded, 0 if it is not
sub isBounded{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	for my $v (@face){
		if ($v >= $num_verts){
			return 0;
		}
	}
	return 1;
}

#usage: facetsList{$newtonPoly}
#returns an AoA of the facets, 
sub facetList{
	my $poly = shift;
	my @flist = @{$poly->VERTICES_IN_FACETS};
	my @result = map(vectorToArray($_), @flist);
	return \@result;
}

#usage:coneHash($diagram, $faceList, $dualFan)
#returns the faces in the order of the rays
#doesn't actually return a hash
#doesn't work
sub badConeHash{
	my $diagram = shift;
	my $facelist = shift;
	my $dualFan = shift;
	my @rays = map(vectorToArray($_), @{$dualFan->RAYS});
	my @faces = map(rayToFacet($_, $diagram, $facelist), @rays);
	return \@faces;
}

#usage: coneHash($facetlist, $diagram)
#diagram must be reduced
#creates a ray - to - facet correspondence by taking the facets of the newton polyhedron, removing the far face
sub coneHash{
	my $flist = shift;
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @good;
	for my $f (@{$flist}){
		if ($f->[0] < $num_verts){
			push(@good, $f)
		}
	}
	return \@good;
}



#usage: coneToFace(list of bounded faces corresponding to each ray, $cone)
#returns arref of the corresponding face
sub coneToFace{
	my $conehash = shift;
	my $cone = shift;
	if (scalar(@$cone == 1)){
		return $conehash->[$cone->[0]];
	}
	my $lc = List::Compare->new(map($conehash->[$_], @{$cone}));
	my @answer = $lc->get_intersection;
	return \@answer;
}

#usage: findFace(cone, diagram)
#takes a cone in the dual cone, returns the face in the newton polyhedron that it corresponds to
#input cone as an array of spanning vertices 
#they should actually be a non-empty cone in the dual fan
#returns the indices of the vertices
#doesn't work
sub findFace{
	my @cone = @{shift @_};
	my $diagram = shift;
	my $n = computeN($cone[0], $diagram);
	my @face;
	for my $vertex (0..(scalar(@{$diagram}) - 1)){
		if (dotProduct($diagram->[$vertex], $cone[0]) == $n){

			push(@face, $vertex);
		}		
	}
	for my $index (1..(scalar(@cone) - 1)){
		$n = computeN($cone[$index], $diagram);
		my @face2;
		for my $vertex (0..(scalar(@{$diagram}) - 1)){
			if (dotProduct($diagram->[$vertex], $cone[$index]) == $n){
				push(@face2, $vertex);
			}
		}
		my $lc = List::Compare->new(\@face, \@face2);
		@face = $lc->get_intersection;		
	}
	return \@face;
}


#usage: localZetaFunction($diagram)
#computes the topological local zeta function
#for now only works for simplicial, because otherwise I need to do something more intelligent to compute the dim of a face
#diagram must be reduced
sub localZetaFunction{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $poly = newtonPolyhedron($diagram);
	my $facetList = facetList($poly, $diagram);
	my $fan = fan::normal_fan($poly);
	my $conehash = coneHash($facetList, $diagram);

	my $zeta = new UniPolynomial("0");
	my @rays = @{$fan->RAYS};
	my @cones = @{allConesByDim($fan)};
	my $factor = new UniPolynomial "x/(x + 1)";
	#cdim + 1 = dimension of cone
	#dimension of face = dim - cdim - 1
	my $tzeta = new UniPolynomial("0");
	for my $cdim (0..($dim - 1)){
		for my $cone (@{$cones[$cdim]}){
			my @theserays = map(\@{$rays[$_]}, @{$cone});
			my $face = coneToFace($conehash, \@{$cone});
			#cones corresponding to non-compact faces
			if (isBounded($face, $diagram) == 0){
				next;
			}

			my $num = scalar(@{$face});

			if ($num == 1){
				$zeta = $zeta + totalContribution(\@theserays, $diagram);
				#my $t = totalContribution(\@theserays, $diagram);
				#if (isPole($t, -184/143)){
				#	pArr $face;
				#	pArr $cone;
				#	print $t;
				#	print "\n";
				#	$tzeta = $tzeta + $t;
				#}
			}
			if ($num > 1){
				my $contrib = totalContribution(\@theserays, $diagram);
				my $fdim = $dim - $cdim - 1;
				my @verts = map($diagram->[$_], @{$face});
				my $coef = powMinusOne($fdim)*normalizedVolume(\@verts);
				#if (isPole($contrib, -184/143)){
				#	if ($num == 2 and $face->[1] == 6){
				#		pArr $face;
				#		pArr $cone;
				#		print $contrib;
				#		print "\n factor is $coef \n";
				#		print $factor*$coef*$contrib;
				#		print "\n";
				#		$tzeta = $tzeta + $factor*$coef*$contrib;
				#	}
				#}
				$zeta = $zeta + $factor*$coef*$contrib;
			}
		}
	}
	return $zeta;
}

#usage: isPole($rational function, $point)
#returns 1 if it is a pole 
#returns 0 if it is not a pole
sub isPole{
	my $rational = shift;
	my $p = shift;
	my $point = new Rational($p);
	my $denom = denominator($rational);
	my $ans = $denom->evaluate($point);
	if ($ans == 0){
		return 1;
	}
	return 0;
}

#usage: allContributingFacets($diagram, $list of facets, $number)
#returns an array with a list of all facets that contribute that number
#diagram must be reduced
#checks if it is within 10^{-5}
sub allContributingFacets{
	my $diagram = shift;
	my $flist = shift;
	my $num = shift;
	my @facets;
	for my $f(@{$flist}){
		if ((abs(candidatePole($diagram, \@{$f}) - $num) < 0.00001)){
			push(@facets, \@{$f});
		}
	}
	return \@facets; 
}

#usage:checkAllForCounterexample($diagram)
#diagramn must be reduced
#checks every pole if it gives a counterexample
#checks if there is a facet with essential face contributing
#doesn't work because it doesn't use exactCandidatePole
sub checkAllForCounterexample{
	my $diagram = shift;
	my $subdiv = nonSimpDiagramToSimp($diagram);
	my $flist = $subdiv->FACETS;
	my $list = allCandidatePoles($diagram);
	my $localzeta = localZetaFunction($diagram);
	my $good = 0;
	for my $num (@{$list}){
		$good = 0;
		if (isPole($localzeta, $num)){
			print "checking ", $num, "\n";
			my $facets = allContributingFacets($diagram, $flist, $num);
			for my $f (@{$facets}){
				if (computeMultiplicity($diagram, $f) > 0){
					$good = 1;
					last;
				}
			}
			if ($good == 0){
				print "Found counterexample";
			return 1;
			}
		}

	}
	return 0;	
}

#usage: quicklyTestDiagram($diagram)
#diagram need not be reduced
#tests topological monodromy conjecture
#does not use any results about when B_1 facets don't give rise to candidate poles
#checks for each pole if there is a B_1 facet that contributes that eigenvalue, there could be other facets
sub quicklyTestDiagram{
	my $diagram = shift;
	$diagram = completelyReduceDiagram($diagram);
	my $subdiv = nonSimpDiagramToSimp($diagram);
	my $perturbed = diagramToPerturbedSubdiv($diagram);
	#finds the universally B_1 facets and B_1 facet
	my @tocheck;
	my @flist = @{$subdiv->FACETS};
	for my $f (@flist){
		my @facet = @{$f};
		if (isB1Facet($diagram, \@facet)){
			push(@tocheck, \@facet);
			next;
		}
		if (noGoodTriangulation($diagram, \@facet)){
			push(@tocheck, \@facet);
		}

	}
	if (scalar(@tocheck) == 0){
		return 0;
	}
	my $localzeta = localZetaFunction($diagram);
	#creates list of real poles that are contribute by (universally) B_1 facets
	my @allcandidates;
	for my $f (@tocheck){
		my @f = @{$f};
		push(@allcandidates, exactCandidatePole($diagram, \@f));
	}
	#checks if these candidates are actually poles
	my @poleslist;
	for my $pole (@allcandidates){
		if (rationalCanonicalMod1($pole) < 0.0000001){
			next;
		}
		if (abs(rationalCanonicalMod1($pole) - 1) < 0.0000001){
			next;
		}
		if (isPole($localzeta, $pole)){
			push(@poleslist, $pole);
		}
	}
	if(scalar(@poleslist) == 0){
		return 0;
	}
	#loops through all facets, checks if their candidate pole is one of the poles 
	#if it is, computes contribution 
	#if contribution is positive, removes corresponding poles
	pArr(\@poleslist);
	for my $f (@flist){
		if (scalar(@{poleslist}) == 0){
			return 0;
		}
		my @facet = @{$f};

		my $tri = findTriangulated($diagram, $perturbed, \@facet)->[0];
		my $num = exactCandidatePole($diagram, $tri);
		my @matching_indices;
		for my $i (0..(scalar(@{poleslist}) - 1)){
			if (abs($num - $poleslist[$i]) < 0.000001){
				push(@matching_indices, $i);
			}
		}
		my $total = scalar(@matching_indices);
		if ($total == 0){
			next;
		}
		if (computeMultiplicity($diagram, \@facet) == 0){
			next;
		}
		#removes the matching indices
		for my $i (0..($total - 1)){
			splice(@poleslist, $matching_indices[$total - 1 - $i], 1);
		}
		pArr(\@poleslist);
	}
	if (scalar(@poleslist) == 0){
		return 0;
	}




	print "Found counterexample!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
	print($localzeta);
	print "\n";
	return 1;

}

#usage: exactCandidatePole($diagram, $facet)
#diagram should be completely reduced 
#facet should be an actual facet 
#returns the candidate pole as a rational number
sub exactCandidatePole{
	my $diagram = shift;
	my $poly = newtonPolyhedron($diagram);
	my $facet = shift;
	my @facets = @{$poly->VERTICES_IN_FACETS};
	for my $index (0..(scalar(@facets) - 1)){
		my $f = $facets[$index];
		for my $i (0..(scalar(@{$facet}) - 1)){
			if ($facet->[$i] != $f->[$i]){
				last;
			}
			if ($i == (scalar(@{$facet}) - 1)){
				my @normal = @{$poly->FACETS->[$index]};
				shift(@normal);
				my $normalized = new Vector(\@normal);
				my $nu = sumArray(\@{$normalized});
				my $N = 0;
				for my $j (0..(scalar(@normal) - 1)){
					$N += ($diagram->[$facet->[0]]->[$j])*($normalized->[$j]);
				}
				my $answer = new Rational(-$nu/$N);
				return $answer;
			}
		}
	}
}


#usage: rationalCanonicalMod1(number)
#finds a representative of the number mod 1 that is between 0 and 1
#works for polymake types
sub rationalCanonicalMod1{
	my $num = shift;
	my $v = new Vector<Rational>([$num]);
	my $real = convert_to<Float>($v);
	return canonicalMod1($real->[0]);
}

#usage: checkIfPoles($diagram, $array of rationals)
#returns a 0/1 array, 1 if the corresponding rational is a pole, 0 if it is not 
#more efficient that computing whole local zeta function hopefully
sub checkIfPoles{

}



#usage:generateDiagramsForMonodromy(dimension, number of iterations)
#returns a bunch of reduced that give triangulations
#may return fewer diagrams because the random diagrams it generates might be non-simplicial
#sumRND is (dim, cbound, general sum, number of vertices)
#produces reduce diagrams!
sub generateDiagramsForMonodromy{
	my $dim = shift;
	my $iter = shift;
	my @diagrams = ();
	for my $i (0..$iter){
		my $diagram = sumRND($dim, 40, 10, 15);
		my $subdiv = diagramToSubdiv($diagram);
		if ($subdiv == 1){
			next;
		}
		$diagram = removeRedundant($diagram, $subdiv);
		push(@diagrams, $diagram);
	}
	return \@diagrams;
}



#usage: totalContribution(rays of a cone, fan, P)
#returns the integral over the cone paired with P
sub integralP{
	my $cone = shift;
	my $fan = shift;
	my @allrays = @{$fan->RAYS};
	my $P = shift;
	my @theserays = map(\@{$rays[$_]}, @{$cone});
	my $primitive = subdivideCone(\@theserays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		my @subdividedrays = map($theserays[$_], @{$tri});
		my @prim = map(changeToPrimitive($_), @subdividedrays);
		my $trianglecontrib = new UniPolynomial(1);
		for my $p (@prim){
			my $pairing = dotProduct($P, $p);
			my $v = sumArray($p);
			my $contrib = new UniPolynomial("$pairing*x + $v");
			$trianglecontrib = $trianglecontrib/$contrib
		}
		$answer = $answer + $trianglecontrib;
	}
	return $answer;
}

#usage: testGeneralConjecture($diagram)
#takes a diagram, finds all B_1 facets
#For each cluster of B_1 facets contributing the same candidate pole, checks if the cluster is coherent 
#if the cluster is not coherent, then it should contribute an eigenvalue
#if all the clusters are coherent, then the pole shouldn't be a pole 
#only works for simplicial
#checks all clusters, not just those consisting only of B_1 facets
#returns 2 if eigenvalue side fails, 1 if pole side, 0 if both okay
sub testGeneralConjecture{
	my $diagram = shift;
	my $subdiv = diagramToSubdiv($diagram);
	my @allfacets = @{$subdiv->FACETS};
	my @polestocheck;
	#my @b1s = @{returnB1Facet($diagram, $subdiv)};
	my $centerclusters = sortIntoClusters($diagram, \@allfacets);
	my @clusters = @{$centerclusters->[1]};
	for my $c (@clusters){
		my $facets = $c;
		my $pole = rationalCandidatePole($diagram, $facets->[0]);
		if ($pole == -1){
			next;
		}
		my $result = checkIfCoherent($diagram, $facets);
		if ($result == 0){
			my $essential = returnQ($diagram, 3, $facets->[0]);
			if (sumArray(relativeLocalH($subdiv, $essential)) == 0){
				print "Contradiction to eigenvalue side with facet \n";
				pArr($facets->[0]);
				pArr(minCritFace($diagram, $facets->[0]));
				return 2;
			}
		}
		else{
			push(@polestocheck, $pole);
		}

	}
	my @allcoherent;
	for my $pole (@polestocheck){
		my @facets = @{allContributingCandidatePole($diagram, \@allfacets, $pole)};
		if (checkIfCoherent($diagram, \@facets) != 0){
			push(@allcoherent, $pole);
		}
	}
	if (scalar(@allcoherent) > 0){
		my $zeta = localZetaFunction($diagram);
		for my $p (@allcoherent){
			if (isPole($zeta, $p)){
				print "Contradiction to pole side ", $p, "\n";
				pArrArr(allContributingCandidatePole($diagram, \@allfacets, $p));
				#pArr(minCritFace($diagram, \@{$contrib[0]}));
				return 1;
			}
		}
	}
	return 0;
}

#useage: testCoherentPoleEigenvalue($diagram, c)
#loops through clusters, checks each cluster if it is coherent, contributes a pole, and contributes an eigenvalue 
#prints the result if the pole is fake, and the center has codimension c
sub testCoherentPoleEigenvalue{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $c = shift;
	my $subdiv = diagramToSubdiv($diagram);
	my @allfacets = @{$subdiv->FACETS};
	my @polestocheck;
	#my @b1s = @{returnB1Facet($diagram, $subdiv)};
	my $centerclusters = sortIntoClusters($diagram, \@allfacets);
	my @clusters = @{$centerclusters->[1]};
	my @centers = @{$centerclusters->[0]};
	my $zeta = localZetaFunction($diagram);

	for my $i (0..(scalar(@clusters) - 1)){
		my $center = $centers[$i];
		if (scalar(@{$center}) != $dim - $c){
			next;
		}
		my $facets = $clusters[$i];
		my $pole = rationalCandidatePole($diagram, $facets->[0]);
		if ($pole == -1){
			next;
		}
		if (isPole($zeta, $pole)){
			next;
		}
		print "Center is: \n";
		pArr($center);
		print "Facets are: \n";
		pArrArr($facets);
		my $result = checkIfCoherent($diagram, $facets);
		if ($result == 0){
			print "Cluster is coherent \n";
		}
		else{
			print "Cluster is not coherent \n";
		}
		my $essential = returnQ($diagram, 3, $facets->[0]);
		if (sumArray(relativeLocalH($subdiv, $essential)) == 0){
			print "Eigenvalue does not contribute \n";
			
		}
		else{
			print "Eigenvalue contributes \n";
		}
		print "Pole is fake \n";



	}

}

sub testEigenvalueCoherent{
	my $diagram = shift;
	my $subdiv = diagramToSubdiv($diagram);
	my @allfacets = @{$subdiv->FACETS};
	my @polestocheck;
	#my @b1s = @{returnB1Facet($diagram, $subdiv)};
	my $centerclusters = sortIntoClusters($diagram, \@allfacets);
	my @clusters = @{$centerclusters->[1]};
	for my $c (@clusters){
		my $facets = $c;
		my $pole = rationalCandidatePole($diagram, $facets->[0]);
		if ($pole == -1){
			next;
		}
		my $result = checkIfCoherent($diagram, $facets);
		if ($result == 0){
			my $essential = returnQ($diagram, 3, $facets->[0]);
			if (sumArray(relativeLocalH($subdiv, $essential)) == 0){
				print "Contradiction to eigenvalue side with facet \n";
				pArrArr($facets);
				pArr(minCritFace($diagram, $facets->[0]));
				return 2;
			}
		}

	}
	return 0;
}


#usage; testELTCoherentFake($diagram)
#checks every cluster of facets
#looks for facets that are [ELT] coherent but have a real pole 
#fake apices with a real pole 
#unexpected fake poles 
#counterexamples to the eigenvalue side 
#doesn't work well if multiple clusters contribute the same pole 
#returns 1 if the pole is unexpectly fake or the eigenvalue unexpectly fails to contribute
#returns 2 if the pole is unexpectly real
#incorporates the cd1 conjecture 
sub testELTCoherentFake{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $subdiv = diagramToSubdiv($diagram);
	my @allfacets = @{$subdiv->FACETS};
	my $centerclusters = sortIntoClusters($diagram, \@allfacets);
	my @clusters = @{$centerclusters->[1]};
	my @centers = @{$centerclusters->[0]};
	my $zeta = localZetaFunction($diagram);
	my $bad = 0;
	for my $i (0..(scalar(@clusters) - 1)){
		my $center = $centers[$i];

		my $facets = $clusters[$i];
		my $pole = rationalCandidatePole($diagram, $facets->[0]);
		if ($pole == -1){
			next;
		}
		#checks for multiple clusters 
		my $allcontributing = allContributingFacets($diagram, \@allfacets, $pole);
		if (scalar(@{$allcontributing}) > scalar(@{$facets})){
			next;
		}
		#does the cd 1 case 
		if (scalar(@{$center}) == ($dim - 1)){
			my $yesorno = isPole($zeta, $pole);
			testCD1Conjecture($diagram, $center, $facets, $yesorno, $subdiv);
			next;
		}

		my $isELT = isELTCoherent($diagram, $facets);
		my $hasapex = hasFakeUniqueApex($diagram, [$center, $facets]);
		if (($isELT == 0) and (scalar(@{$hasapex}) == 0)){
			#in this case pole should be real, eigenvalue should be real
			if (not isPole($zeta, $pole)){
				pArrArr($facets);
				print "Pole is fake \n";
				$bad = 1;
			}
			my $essential = returnQ($diagram, 3, $facets->[0]);
			if (sumArray(relativeLocalH($subdiv, $essential)) == 0){
				pArrArr($facets);
				print "Eigenvalue does not contribute \n";
				$bad = 1;
			}

		}

		else{
			#pole should be fake, eigenvalue couold be real or fake
			if (isPole($zeta, $pole)){
				if (not ($isELT == 0)){
					pArrArr($facets);
					print "Counterexample to [ELT] \n";
					$bad = 2;
				}
				if (not scalar(@{$hasapex}) == 0){
					pArrArr($facets);
					print "Real pole even though fake apex \n";
					$bad = 2;
				}
			}
		}




	}
	if ($bad == 1){
		return 1;
	}
	if ($bad == 2){
		return 2;
	}
	return 0;

}

#usage: testOperativeConjecture($diagram)
#tests the conjecture that the existence of an operative labeling determines if a pole is fake
#doesn't work well if multiple clusters contribute the same pole 

sub testOperativeConjecture{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $subdiv = diagramToSubdiv($diagram);
	my @allfacets = @{$subdiv->FACETS};
	my $centerclusters = sortIntoClusters($diagram, \@allfacets);
	my @clusters = @{$centerclusters->[1]};
	my @centers = @{$centerclusters->[0]};
	my $zeta = localZetaFunction($diagram);
	my $bad = 0;
	for my $i (0..(scalar(@clusters) - 1)){
		my $center = $centers[$i];

		my $facets = $clusters[$i];
		my $pole = rationalCandidatePole($diagram, $facets->[0]);
		if ($pole == -1){
			next;
		}
		#checks for multiple clusters 
		my $allcontributing = allContributingFacets($diagram, \@allfacets, $pole);
		if (scalar(@{$allcontributing}) > scalar(@{$facets})){
			next;
		}
		#eigenvalue should be real in the following case
		if (checkForOperative($diagram, $subdiv, $center) == 0){
			if (not isPole($zeta, $pole)){
				pArrArr($facets);
				print "Pole is fake \n";
				$bad = 1;
			}
			my $essential = returnQ($diagram, 3, $facets->[0]);
			if (sumArray(relativeLocalH($subdiv, $essential)) == 0){
				pArrArr($facets);
				print "Eigenvalue does not contribute, operative conjecture is wrong \n";
				$bad = 1;
			}

		}
		else{
			#pole should be fake, eigenvalue couold be real or fake
			if (isPole($zeta, $pole)){
				pArrArr($facets);
				print "Pole should be fake but is not \n";
				$bad = 2;
			}			
		}
	}
	if ($bad == 1){
		return 1;
	}
	if ($bad == 2){
		return 2;
	}
	return 0;


}

