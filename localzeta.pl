#!/usr/bin/perl
#Contributors: Matt Larson
#Last updated: 01/29/2021

#computes the topological local zeta function associated to a Newton polyhedron

use strict;
use warnings;
use application "polytope";
use Algorithm::Combinatorics "subsets";

script("/Users/matthew/Desktop/Local_Zeta_Function/code/subs.pl");

#has code for computing the topological zeta function 



#usage: multiplicityArray(AoA)
#computes the multiplicity of an array of r integer vectors
#i.e. computes the index of the lattice generated by the vectors in the group of all lattice points 
#in the vector space spanned by the vectors
#does this by taking the gcd of the determinents of the rxr minors
sub multiplicityArray{
	my @input = @{shift @_};
	my @vecs = map(latticePointToArray($_), @input);
	my $mat = new Matrix<Integer>(\@vecs);
	my $v = pluecker($mat);
	return gcd($v);
}
#usage: newtonPolyhedron($diagram)
#diagram does not need to be reduced
#outputs the newton polyhedron as a polyhedron
sub newtonPolyhedron{
	my $diagram = shift;
	my $proj = toReverseProjectiveArray($diagram);
	my $dim = scalar(@{$diagram->[0]});
	my $verts = standard_simplex_vertices($dim - 1);
	map(unshift($_, 0), @{$verts});
	push(@{$proj}, @{$verts});
	my $Mat=new Matrix<Rational>($proj);
	my $p = new Polytope(POINTS=>$Mat);
	return $p;
}

#usage: dualFan($diagram)
#creates the dual fan by making the newton polyhedron
sub dualFan{
	my $diagram = shift;
	my $newton = newtonPolyhedron($diagram);
	my $fan = fan::normal_fan($newton);
	return $fan;
}

#usage: changeToPrimitive($arref)
#assumes every entry is either 1 or 0 or a non-integer Rational - must use the polymake type
#returns a primitive integer vector in that direction
sub changeToPrimitive{
	my @array = @{shift @_};
	#@array = map(vectorToArray($_), @array);
	my $denom = 1;
	for my $n (@array){
		if (($n == 0) or ($n == 1)){
			next;
		}
		$denom = denominator($n) * $denom;
	}
	my @result;
	for my $n (@array){
		my $a = new Integer($n * $denom);
		push(@result, $a);
	}
	return makePrimitive(\@result);
}


#usage: computeN($point, $diagram)
#takes a point in the dual fan
#compute the minimimum value of the pairing of that with the newton polyhedron
sub computeN{
	my $point = shift;
	my $diagram = shift;
	my $best = dotProduct($point, $diagram->[0]);
	for my $i (0..(scalar(@{$diagram}) - 1)){
		if ($best > dotProduct($point, $diagram->[$i])){
			$best = dotProduct($point, $diagram->[$i]);
		}
	}
	return $best;
}

#usage: jDelta(arref of points, diagram)
#computes J_{\Delta} for the cone spanned by these points
#points should be primitive, but will make sense if not
sub jDelta{
	my @points = @{shift @_};
	my $diagram = shift;
	my $mult = multiplicityArray(\@points);
	#my $mult = 1;
	my $answer = new UniPolynomial($mult);
	for my $p (@points){
		my $n = computeN($p, $diagram);
		my $v = sumArray($p);
		my $contrib = new UniPolynomial("$n*x + $v");
		$answer = $answer/$contrib
	}
	return $answer;
}

#usage: normalizedVolume($arref of lattice points)
#returns the normalized volume of the convex hull of the vertices
sub normalizedVolume{
	my $vertices = shift;
	my $proj = toReverseProjectiveArray($vertices);
	my $poly = new LatticePolytope(POINTS=>$proj);
	return $poly->LATTICE_VOLUME;

}

#usage: subdivideCone(arref of vertices)
#returns a subdivision of the cone by the convex hull of the vertices 
sub subdivideCone{
	my @rays = @{shift @_};
	my $cone = new Cone(RAYS=>\@rays);
	my $t = $cone->TRIANGULATION;
	my $vectorsubdiv = $t->FACETS;
	my @subdiv = map(vectorToArray($_), @{$vectorsubdiv});
	return \@subdiv;
}

#usage: totalContribution(rays of a cone, diagram)
#subdivides the cone into rational simplicial parts and returns the total contribution
sub totalContribution{
	my $rays = shift;
	my $diagram = shift;
	my $primitive = subdivideCone($rays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		my @subdividedrays = map($rays->[$_], @{$tri});
		my @prim = map(changeToPrimitive($_), @subdividedrays);
		$answer = $answer + jDelta(\@prim, $diagram);
	}
	return $answer;
}


#usage: allCones(Fan)
#returns all cones of the fan
#includes the empty cone
sub allCones{
	my $fan = shift;
	my @cones = @{$fan->MAXIMAL_CONES};
	my @allcones;
	my %hash;	
	for my $cone (@cones){
		my @c = @{$cone};
		my @subcones = subsets(\@c);
		for my $sc (@subcones){
			my $str = "@{$sc}";
			if (not $hash{$str}){
				$hash{$str} = 1;
				push(@allcones, $sc);
			}
		}
	}
	return \@allcones;
}


#usage: allConesByDim($fan)
#returns an Array of Array of Arrays
#first array is the dimension of the cone
#second AoA contains all cones of that dimension
sub allConesByDim{
	my $fan = shift;
	my @cones = @{$fan->CONES};
	my @results;
	for my $i (0..(($fan->DIM) - 1)){
		my @cdims = map(vectorToArray($_), @{$cones[$i]});
		push(@results, \@cdims);
	}
	return \@results;
}

#usage: rayToFacet(ray, diagram, sorted AoA of bounded facets)
#the AoA must be a sorted (by decreasing length) array of the bounded faces of the newton polyhedron 
#facet should be given as a list of vertices in the diagram, diagram should be reduced
#returns the facet corresponding to the array
#does this by looping through the facets, 
#checking if the pairing of ray with all vertices in them is the same
#if it doesn't match any of them then returns -1
sub rayToFacet{
	my @ray = @{shift @_};
	my $diagram = shift;
	my @flist = @{shift @_};
	my $correct = 1;
	my $num = computeN(\@ray, $diagram);
	for my $f (@flist){
		$correct = 1;
		for my $i (0..(scalar(@{$f}) - 1)){
			if ($num != dotProduct(\@ray, $diagram->[$f->[$i]])){
				$correct = 0;
				last;
			}
		}
		if ($correct == 1){
			return $f;
		}

	}
	return -1;
}

#usage: boundedPart(face, diagram)
#returns the maximal bounded face contained in the face
#diagram must be reduced
sub boundedPart{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @new_face;
	for my $v (@face){
		if ($v < $num_verts){
			push(@new_face, $v);
		}
	}
	return \@new_face;
}

#usage: isBounded($face, $diagram)
#returns 1 if the face is bounded, 0 if it is not
sub isBounded{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	for my $v (@face){
		if ($v >= $num_verts){
			return 0;
		}
	}
	return 1;
}

#usage: facetsList{$newtonPoly}
#returns an AoA of the facets, 
sub facetList{
	my $poly = shift;
	my @flist = @{$poly->VERTICES_IN_FACETS};
	my @result = map(vectorToArray($_), @flist);
	return \@result;
}


#usage: coneHash($facetlist, $diagram)
#diagram must be reduced
#creates a ray - to - facet correspondence by taking the facets of the newton polyhedron, 
#removing the far face
sub coneHash{
	my $flist = shift;
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @good;
	for my $f (@{$flist}){
		if ($f->[0] < $num_verts){
			push(@good, $f)
		}
	}
	return \@good;
}



#usage: coneToFace(list of bounded faces corresponding to each ray, $cone)
#returns arref of the corresponding face
sub coneToFace{
	my $conehash = shift;
	my $cone = shift;
	if (scalar(@$cone == 1)){
		return $conehash->[$cone->[0]];
	}
	my $lc = List::Compare->new(map($conehash->[$_], @{$cone}));
	my @answer = $lc->get_intersection;
	return \@answer;
}



#usage: localZetaFunction($diagram)
#computes the topological local zeta function
#for now only works for simplicial, because otherwise I need to do something more intelligent 
#to compute the dim of a face
#diagram must be reduced
sub localZetaFunction{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $poly = newtonPolyhedron($diagram);
	my $facetList = facetList($poly, $diagram);
	my $fan = fan::normal_fan($poly);
	my $conehash = coneHash($facetList, $diagram);

	my $zeta = new UniPolynomial("0");
	my @rays = @{$fan->RAYS};
	my @cones = @{allConesByDim($fan)};
	my $factor = new UniPolynomial "x/(x + 1)";
	#cdim + 1 = dimension of cone
	#dimension of face = dim - cdim - 1
	for my $cdim (0..($dim - 1)){
		for my $cone (@{$cones[$cdim]}){
			my @theserays = map(\@{$rays[$_]}, @{$cone});
			my $face = coneToFace($conehash, \@{$cone});
			#cones corresponding to non-compact faces
			if (isBounded($face, $diagram) == 0){
				next;
			}

			my $num = scalar(@{$face});

			if ($num == 1){
				$zeta = $zeta + totalContribution(\@theserays, $diagram);
			}
			if ($num > 1){
				my $contrib = totalContribution(\@theserays, $diagram);
				my $fdim = $dim - $cdim - 1;
				my @verts = map($diagram->[$_], @{$face});
				my $coef = powMinusOne($fdim)*normalizedVolume(\@verts);
				$zeta = $zeta + $factor*$coef*$contrib;
			}
		}
	}
	return $zeta;
}

#usage: isPole($rational function, $point)
#returns 1 if it is a pole 
#returns 0 if it is not a pole
sub isPole{
	my $rational = shift;
	my $p = shift;
	my $point = new Rational($p);
	my $denom = denominator($rational);
	my $ans = $denom->evaluate($point);
	if ($ans == 0){
		return 1;
	}
	return 0;
}

#usage: allContributingFacets($diagram, $list of facets, $number)
#returns an array with a list of all facets that contribute that number
#diagram must be reduced
#checks if it is within 10^{-5}
sub allContributingFacets{
	my $diagram = shift;
	my $flist = shift;
	my $num = shift;
	my @facets;
	for my $f(@{$flist}){
		if ((abs(candidatePole($diagram, \@{$f}) - $num) < 0.00001)){
			push(@facets, \@{$f});
		}
	}
	return \@facets; 
}



#usage: exactCandidatePole($diagram, $facet)
#diagram should be completely reduced 
#facet should be an actual facet 
#returns the candidate pole as a rational number
sub exactCandidatePole{
	my $diagram = shift;
	my $poly = newtonPolyhedron($diagram);
	my $facet = shift;
	my @facets = @{$poly->VERTICES_IN_FACETS};
	for my $index (0..(scalar(@facets) - 1)){
		my $f = $facets[$index];
		for my $i (0..(scalar(@{$facet}) - 1)){
			if ($facet->[$i] != $f->[$i]){
				last;
			}
			if ($i == (scalar(@{$facet}) - 1)){
				my @normal = @{$poly->FACETS->[$index]};
				shift(@normal);
				my $normalized = new Vector(\@normal);
				my $nu = sumArray(\@{$normalized});
				my $N = 0;
				for my $j (0..(scalar(@normal) - 1)){
					$N += ($diagram->[$facet->[0]]->[$j])*($normalized->[$j]);
				}
				my $answer = new Rational(-$nu/$N);
				return $answer;
			}
		}
	}
}


#usage: rationalCanonicalMod1(number)
#finds a representative of the number mod 1 that is between 0 and 1
#works for polymake types
sub rationalCanonicalMod1{
	my $num = shift;
	my $v = new Vector<Rational>([$num]);
	my $real = convert_to<Float>($v);
	return canonicalMod1($real->[0]);
}





#usage:generateDiagramsForMonodromy(dimension, number of iterations)
#returns a bunch of reduced that give triangulations
#may return fewer diagrams because the random diagrams it generates might be non-simplicial
#sumRND is (dim, cbound, general sum, number of vertices)
#produces reduce diagrams!
sub generateDiagramsForMonodromy{
	my $dim = shift;
	my $iter = shift;
	my @diagrams = ();
	for my $i (0..$iter){
		my $diagram = sumRND($dim, 40, 10, 15);
		my $subdiv = diagramToSubdiv($diagram);
		if ($subdiv == 1){
			next;
		}
		$diagram = removeRedundant($diagram, $subdiv);
		push(@diagrams, $diagram);
	}
	return \@diagrams;
}



#usage: integralP(rays of a cone, fan, P)
#returns the integral over the cone paired with P
sub integralP{
	my $cone = shift;
	my $fan = shift;
	my @allrays = @{$fan->RAYS};
	my $P = shift;
	my @theserays = map(\@{$allrays[$_]}, @{$cone});
	my $primitive = subdivideCone(\@theserays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		my @subdividedrays = map($theserays[$_], @{$tri});
		my @prim = map(changeToPrimitive($_), @subdividedrays);
		my $mult = multiplicityArray(\@prim);
		my $trianglecontrib = new UniPolynomial($mult);
		for my $p (@prim){
			my $pairing = dotProduct($P, $p);
			my $v = sumArray($p);
			my $contrib = new UniPolynomial("$pairing*x + $v");
			$trianglecontrib = $trianglecontrib/$contrib;
		}
		$answer = $answer + $trianglecontrib;
	}
	return $answer;
}



#usage: makeArrayRational(array)
#turns it into a polymake rational vector
sub makeArrayRational{
	my $array = shift;
	my $vec = new Vector<Rational>($array);
	return $vec;
}

#usage: integralPExplicit(array of rays, vertex)
#returns the integral with respect ot the vertex over the cone spanned by the rays
sub integralPExplicit{
	my $rays = shift;
	my $vertex = shift;
	my $primitive = subdivideCone($rays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		pArr($tri);
		my @subdividedrays = map($rays->[$_], @{$tri});
		my @prim = map(changeToPrimitive(makeArrayRational($_)), @subdividedrays);
		my $mult = multiplicityArray(\@prim);
		print "Multiplicity is $mult \n";
		my $trianglecontrib = new UniPolynomial($mult);
		for my $p (@prim){
			my $pairing = dotProduct($vertex, $p);
			my $v = sumArray($p);
			my $contrib = new UniPolynomial("$pairing*x + $v");
			$trianglecontrib = $trianglecontrib/$contrib;
		}
		print $trianglecontrib;
		print "\n";
		$answer = $answer + $trianglecontrib;
	}
	return $answer;

}

#usage: faceToCone($diagram, $face, $list of rays of dual fan)
#finds the cone that is dual to the face 
sub faceToCone{
	my $diagram = shift;
	my $face = shift;
	my $rays = shift;
	my @cone;
	for my $r (@{$rays}){
		my $bad = 0;
		my $pairing = dotProduct($r, $diagram->[$face->[0]]);
		for my $v (@{$face}){
			if (dotProduct($r, $diagram->[$v])!= $pairing){
				$bad = 1;
				last;
			}
		}
		if ($bad == 1){
			next;
		}
		for my $v (@{$diagram}){
			if (dotProduct($r, $v) < $pairing){
				$bad = 1;
				last;
			}
		}
		if ($bad == 1){
			next;
		}
		push(@cone, changeToPrimitive($r));		
	}
	return \@cone;
}




#usage: integrateCone(diagram, integrating vertex (apex), base 1, base 2, base direction)
#[base1, base2] should be an edge 
#integrates exp(-<x (IV) + \one, u)du over Conv(dual cone to edge, base direction)
sub integrateCone{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $IV = shift;
	my $BV1 = shift;
	my $BV2 = shift;
	my $B1direction = shift;
	my $fan = dualFan($diagram);
	my @rays = @{$fan->RAYS};
	my $cone = faceToCone($diagram, [$BV1, $BV2], \@rays);
	my @otherray = (0) x $dim;
	$otherray[$B1direction] = 1;
	push(@{$cone}, \@otherray);
	return integralPExplicit($cone, $diagram->[$IV]);

}

#usage: lookForType11($diagram)
#returns 1 if it has a face of type (1,1,1)
#returns 0 otherwise
sub lookForType11{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $subdiv = diagramToSubdiv($diagram);
	my $clusters = sortIntoClusters($diagram, \@{$subdiv->FACETS});
	my $centers = $clusters->[0];
	for my $c (@{$centers}){
		if (scalar(@{$c}) != $dim - 2){
			next;
		}
		if (scalar(@{returnUniqueApex($diagram, $c)}) == 3){
			pArr($c);
			return 1;
		}
	}
	return 0;
}


sub findLinkSize{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $subdiv = diagramToSubdiv($diagram);
	my $clusters = sortIntoClusters($diagram, \@{$subdiv->FACETS});
	my $centers = $clusters->[0];
	for my $c (@{$centers}){
		if (scalar(@{$c}) != $dim - 2){
			next;
		}
		if (scalar(@{returnUniqueApex($diagram, $c)}) == 3){
			my $link = new topaz::GeometricSimplicialComplex(topaz::link_complex($subdiv, $c));
			pArr($c);
			print $link->N_VERTICES;
			print "\n";
			print $link->VERTEX_LABELS;
			print "\n \n";
		}
	}
}

#usage: localZetaFunctionExplicit($diagram)
#computes the topological local zeta function
#for now only works for simplicial, because otherwise I need to do something more intelligent 
#to compute the dim of a face
#diagram must be reduced
#prints out contribution of each face as it computes
sub localZetaFunctionExplicit{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $poly = newtonPolyhedron($diagram);
	my $facetList = facetList($poly, $diagram);
	my $fan = fan::normal_fan($poly);
	my $conehash = coneHash($facetList, $diagram);

	my $zeta = new UniPolynomial("0");
	my @rays = @{$fan->RAYS};
	my @cones = @{allConesByDim($fan)};
	my $factor = new UniPolynomial "x/(x + 1)";
	my $pole = new Rational(-2);
	#cdim + 1 = dimension of cone
	#dimension of face = dim - cdim - 1
	for my $cdim (0..($dim - 1)){
		for my $cone (@{$cones[$cdim]}){
			my @theserays = map(\@{$rays[$_]}, @{$cone});
			my $face = coneToFace($conehash, \@{$cone});
			#cones corresponding to non-compact faces
			if (isBounded($face, $diagram) == 0){
				next;
			}

			my $num = scalar(@{$face});

			if ($num == 1){
				my $t = totalContribution(\@theserays, $diagram);
				if (isPole($t, $pole)){
					pArr($face);
					pArrArr(\@theserays);
					print($t);
					print "\n \n";
				}
				$zeta = $zeta + $t;

			}
			if ($num > 1){
				my $contrib = totalContribution(\@theserays, $diagram);
				my $fdim = $dim - $cdim - 1;
				my @verts = map($diagram->[$_], @{$face});
				my $coef = powMinusOne($fdim)*normalizedVolume(\@verts);
				$zeta = $zeta + $factor*$coef*$contrib;
				if (isPole($contrib, $pole)){
					pArr($face);
					pArrArr(\@theserays);
					print($factor*$coef*$contrib);
					print "\n \n";
				}
			}
		}
	}
	return $zeta;
}

#usage: contribFromFlag($diagram, vertex, added vertices, maxapex, tuple of directions)
#added vertices are max face -  min face
#computes the corresponding integral 
#directions are all directions of one of the faces in the flag, in order
#directions should be 0-indexed
sub contribFromFlag{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $vertex = shift;
	my $added = shift;
	my $maxapex = shift;
	my $directions = shift;
	my $fan = dualFan($diagram);
	my @rays = @{$fan->RAYS};
	#case when it contains the max apex
	if ($vertex == $maxapex){
		my $face = union([$vertex], $added);
		my $cone = faceToCone($ex, $face, \@rays);
		for my $i (0..(scalar(@{$directions}) - 2)){
			my @otherdirection = (0) x $dim;
			$otherdirection[$directions->[$i]] = 1;
			push(@{$cone}, \@otherdirection);
		}
		return integralPExplicit($cone, $diagram->[$maxapex]);
	}
	my $face = union([$vertex], $added);
	$face = union($face, [$maxapex]);
	my $cone = faceToCone($ex, $face, \@rays);
	for my $i (0..(scalar(@{$directions}) - 1)){
		my @otherdirection = (0) x $dim;
		$otherdirection[$directions->[$i]] = 1;
		push(@{$cone}, \@otherdirection);
	}
	pArrArr($cone);
	return integralPExplicit($cone, $diagram->[$maxapex]);

}



#usage: contribFromFlagOtherVertex($diagram, vertex, added vertices, maxapex, tuple of directions, $IV)
#added vertices are max face -  min face
#computes the corresponding integral 
#directions should be 0-indexed
#IV is the integrating vertex
sub contribFromFlagOtherVertex{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $vertex = shift;
	my $added = shift;
	my $maxapex = shift;
	my $directions = shift;
	my $IV = shift;
	my $fan = dualFan($diagram);
	my @rays = @{$fan->RAYS};
	#case when it contains the max apex
	if ($vertex == $maxapex){
		my $face = union([$vertex], $added);
		my $cone = faceToCone($diagram, $face, \@rays);
		for my $i (0..(scalar(@{$directions}) - 2)){
			my @otherdirection = (0) x $dim;
			$otherdirection[$directions->[$i]] = 1;
			push(@{$cone}, \@otherdirection);
		}
		return integralPExplicit($cone, $diagram->[$IV]);
	}
	my $face = union([$vertex], $added);
	$face = union($face, [$maxapex]);
	my $cone = faceToCone($diagram, $face, \@rays);
	for my $i (0..(scalar(@{$directions}) - 1)){
		my @otherdirection = (0) x $dim;
		$otherdirection[$directions->[$i]] = 1;
		push(@{$cone}, \@otherdirection);
	}
	return integralPExplicit($cone, $diagram->[$IV]);

}


#usage: hasUniqueMinimalFace(diagram, facet)
#returns 1 if the facet contains a unique minimal critical face 
#returns 0 otherwise 
#Only interesting if the facet is simplicial 
sub hasUniqueMinimalFace{
	my $diagram = shift;
	my $facet = shift;
	my $dim = scalar(@{$diagram->[0]});
	my @spanning = subsets($facet, $dim);
	my %hash;
	for my $candidate(@spanning){
		#checks if a given set of vertices are linearly independent
		my @verts;
		for my $i (@{$candidate}){
			push(@verts, $diagram->[$i]);
		}
		my $m = new Matrix<Integer>(\@verts);
		if (common::det($m) == 0){
			next;
		}
		my $mincrit = minCritFace($diagram, $candidate);
		my $str = "@{$mincrit}";
		if (not $hash{$str}){
			$hash{$str} = 1;
		}
	}
	if (scalar keys %hash > 1){
		print "Found counterexample \n";
		pArrArr($diagram);
		pArr($facet);
		return 1;
	}
	return 0;	
}

#usage: checkDiagramForUniqueMinimalFace($diagram)
#checks all non-simplicial facets to see if they have a unique minimal face
sub checkDiagramForUniqueMinimalFace{
	my $diagram = shift;
	my $poly = nonSimpDiagramToSimp($diagram);
	my $facets = $poly->FACETS;
	my $dim = scalar(@{$diagram->[0]});
	for my $f (@{$facets}){
		if (scalar(@{$f}) == $dim){
			next;
		}
		print "found nonsimp";
		hasUniqueMinimalFace($diagram, \@{$f});
	}
}









