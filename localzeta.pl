#!/usr/bin/perl
#Contributors: Matt Larson
#Last updated: 12/05/2019

#computes the topological local zeta function associated to a Newton polyhedron

use strict;
use warnings;
use application "polytope";
use PDL;
use Algorithm::Combinatorics "subsets";
#use Math::Matrix;

script("/Users/matthew/Desktop/Local_Zeta_Function/code/subs.pl");

#usage: multiplicityArray(AoA)
#computes the multiplicity of an array of r integer vectors
#i.e. computes the index of the lattice generated by the vectors in the group of all lattice points 
#in the vector space spanned by the vectors
#does this by taking the gcd of the determinents of the rxr minors
sub multiplicityArray{
	my @input = @{shift @_};
	my @vecs = map(latticePointToArray($_), @input);
	my $num = scalar(@vecs);
	my @minors = subsets([0..scalar(@{$vecs[0]})-1], $num);
	#constructs matrix 
	my @matrixAoa = ();
	for my $i(0..($num - 1)){
		my @row = ();
		for my $j (0..($num - 1)){
			push(@row, $vecs[$i]->[$j]);
		}
		push(@matrixAoa, \@row);
	}
	my $a = pdl[\@matrixAoa];
	my $d = det($a);
	my $gcd;
	if ($d == 0){
		$gcd = 0;
	}
	else{
		$gcd = new Integer abs((det($a)->list)[0]);
	}
	for my $sub(@minors){
		@matrixAoa = ();
		for my $i(0..($num - 1)){
			my @row = ();
			for my $j (0..($num - 1)){
				push(@row, $vecs[$i]->[$sub->[$j]]);
			}
			push(@matrixAoa, \@row);
		}
		$a = pdl[\@matrixAoa];
		my $d = det($a);
		if ($d == 0){
			$gcd = 0;
		}
		else{
			my $toint = new Integer(abs((det($a)->list)[0]));
			$gcd = gcd($gcd, $toint);
		}
		if ($gcd == 1){
			last;
		}
	}
	return $gcd;
}

#usage: newtonPolyhedron($diagram)
#diagram does not need to be reduced
#outputs the newton polyhedron as a polyhedron
sub newtonPolyhedron{
	my $diagram = shift;
	my $proj = toReverseProjectiveArray($diagram);
	my $dim = scalar(@{$diagram->[0]});
	my $verts = standard_simplex_vertices($dim - 1);
	map(unshift($_, 0), @{$verts});
	push(@{$proj}, @{$verts});
	my $Mat=new Matrix<Rational>($proj);
	my $p = new Polytope(POINTS=>$Mat);
	return $p;
}

#usage: dualFan($diagram)
#creates the dual fan by making the newton polyhedron
sub dualFan{
	my $diagram = shift;
	my $newton = newtonPolyhedron($diagram);
	my $fan = fan::normal_fan($newton);
	return $fan;
}

#usage: changeToPrimitive($arref)
#assumes every entry is either 1 or 0 or a non-integer Rational - must use the polymake type
#returns a primitive integer vector in that direction
sub changeToPrimitive{
	my @array = @{shift @_};
	#@array = map(vectorToArray($_), @array);
	my $denom = 1;
	for my $n (@array){
		if (($n == 0) or ($n == 1)){
			next;
		}
		$denom = denominator($n) * $denom;
	}
	my @result;
	for my $n (@array){
		my $a = new Integer($n * $denom);
		push(@result, $a);
	}
	return makePrimitive(\@result);
}

#usage:dotProduct($aref, $aref)
#arefs should be the same length
#computes the dot product
sub dotProduct{
	my $vec1 = shift;
	my $vec2 = shift;
	my $answer = 0;
	for my $i (0..(scalar(@{$vec1}) - 1)){
		$answer += ($vec1->[$i])*($vec2->[$i]);
	}
	return $answer;
}


#usage: computeN($point, $diagram)
#takes a point in the dual fan
#compute the minimimum value of the pairing of that with the newton polyhedron
sub computeN{
	my $point = shift;
	my $diagram = shift;
	my $best = dotProduct($point, $diagram->[0]);
	for my $i (0..(scalar(@{$diagram}) - 1)){
		if ($best > dotProduct($point, $diagram->[$i])){
			$best = dotProduct($point, $diagram->[$i]);
		}
	}
	return $best;
}

#usage: jDelta(arref of points, diagram)
#computes J_{\Delta} for the cone spanned by these points
#points should be primitive, but will make sense if not
sub jDelta{
	my @points = @{shift @_};
	my $diagram = shift;
	my $mult = multiplicityArray(\@points);
	#my $mult = 1;
	my $answer = new UniPolynomial($mult);
	for my $p (@points){
		my $n = computeN($p, $diagram);
		my $v = sumArray($p);
		my $contrib = new UniPolynomial("$n*x + $v");
		$answer = $answer/$contrib
	}
	#print $answer, "\n";
	return $answer;
}

#usage: normalizedVolume($arref of lattice points)
#returns the normalized volume of the convex hull of the vertices
sub normalizedVolume{
	my $vertices = shift;
	my $proj = toReverseProjectiveArray($vertices);
	my $poly = new LatticePolytope(POINTS=>$proj);
	return $poly->LATTICE_VOLUME;

}

#usage: subdivideCone(arref of vertices)
#returns a subdivision of the cone by the convex hull of the vertices 
sub subdivideCone{
	my $rays = shift;
	my $cone = new Cone(RAYS=>$rays);
	my $t = $cone->TRIANGULATION;
	my $vectorsubdiv = $t->FACETS;
	my @subdiv = map(vectorToArray($_), @{$vectorsubdiv});
	return \@subdiv;
}

#usage: totalContribution(rays of a cone, diagram)
#subdivides the cone into rational simplicial parts and returns the total contribution
sub totalContribution{
	my $rays = shift;
	my $diagram = shift;
	my $primitive = subdivideCone($rays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		my @subdividedrays = map($rays->[$_], @{$tri});
		#pArrArr(\@subdividedrays);
		my @prim = map(changeToPrimitive($_), @subdividedrays);
		$answer = $answer + jDelta(\@prim, $diagram);
	}
	return $answer;
}


#usage: allCones(Fan)
#returns all cones of the fan
#includes the empty cone
sub allCones{
	my $fan = shift;
	my @cones = @{$fan->MAXIMAL_CONES};
	my @allcones;
	my %hash;	
	for my $cone (@cones){
		my @c = @{$cone};
		my @subcones = subsets(\@c);
		for my $sc (@subcones){
			my $str = "@{$sc}";
			if (not $hash{$str}){
				$hash{$str} = 1;
				push(@allcones, $sc);
			}
		}
	}
	return \@allcones;
}


#usage: allConesByDim($fan)
#returns an Array of Array of Arrays
#first array is the dimension of the cone
#second AoA contains all cones of that dimension
sub allConesByDim{
	my $fan = shift;
	my @cones = @{$fan->CONES};
	my @results;
	for my $i (0..(($fan->DIM) - 1)){
		my @cdims = map(vectorToArray($_), @{$cones[$i]});
		push(@results, \@cdims);
	}
	return \@results;
}

#usage: rayToFacet(ray, diagram, sorted AoA of bounded facets)
#the AoA must be a sorted (by decreasing length) array of the bounded faces of the newton polyhedron 
#facet should be given as a list of vertices in the diagram, diagram should be reduced
#returns the facet corresponding to the array
#does this by looping through the facets, checking if the pairing of ray with all vertices in them is the same
#if it doesn't match any of them then returns -1
sub rayToFacet{
	my @ray = @{shift @_};
	my $diagram = shift;
	my @flist = @{shift @_};
#	my $num = 0;
	my $correct = 1;
	my $num = computeN(\@ray, $diagram);
	for my $f (@flist){
		$correct = 1;
		#$num = dotProduct(\@ray, $diagram->[$f->[0]]);
		for my $i (0..(scalar(@{$f}) - 1)){
			if ($num != dotProduct(\@ray, $diagram->[$f->[$i]])){
				$correct = 0;
				last;
			}
		}
		if ($correct == 1){
			return $f;
		}

	}
	return -1;
}

#usage: boundedPart(face, diagram)
#returns the maximal bounded face contained in the face
#diagram must be reduced
sub boundedPart{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @new_face;
	for my $v (@face){
		if ($v < $num_verts){
			push(@new_face, $v);
		}
	}
	return \@new_face;
}

#usage: boundedFaceList{$newtonPoly, $diagram}
#returns a list of the maximal bounded faces 
#might not be unique, but all will be on there and all will be bounded
sub boundedFaceList{
	my $poly = shift;
	my $diagram = shift;
	my @flist = @{$poly->VERTICES_IN_FACETS};
	my @bflist = map(boundedPart($_, $diagram), @flist);
	return \@bflist;
}

#usage:coneHash($diagram, $boundedFaceList, $dualFan)
#returns the faces in the order of the rays
#doesn't actually return a hash
sub coneHash{
	my $diagram = shift;
	my $bfacelist = shift;
	my @sbfacelist = sort { @$b <=> @$a } @{$bfacelist};
	my $dualFan = shift;
	my @rays = map(vectorToArray($_), @{$dualFan->RAYS});
	my @faces = map(rayToFacet($_, $diagram, \@sbfacelist), @rays);
	return \@faces;
}

#usage: coneToFace(list of bounded faces corresponding to each ray, $cone)
#returns arref of the corresponding face
sub coneToFace{
	my $conehash = shift;
	my $cone = shift;
	if (scalar(@$cone == 1)){
		return $conehash->[$cone->[0]];
	}
	my $lc = List::Compare->new(map($conehash->[$_], @{$cone}));
	my @answer = $lc->get_intersection;
	return \@answer;
}

#usage: findFace(cone, diagram)
#takes a cone in the dual cone, returns the face in the newton polyhedron that it corresponds to
#input cone as an array of spanning vertices 
#they should actually be a non-empty cone in the dual fan
#returns the indices of the vertices
#doesn't work
sub findFace{
	my @cone = @{shift @_};
	my $diagram = shift;
	my $n = computeN($cone[0], $diagram);
	my @face;
	for my $vertex (0..(scalar(@{$diagram}) - 1)){
		if (dotProduct($diagram->[$vertex], $cone[0]) == $n){

			push(@face, $vertex);
		}		
	}
	for my $index (1..(scalar(@cone) - 1)){
		$n = computeN($cone[$index], $diagram);
		my @face2;
		for my $vertex (0..(scalar(@{$diagram}) - 1)){
			if (dotProduct($diagram->[$vertex], $cone[$index]) == $n){
				push(@face2, $vertex);
			}
		}
		my $lc = List::Compare->new(\@face, \@face2);
		@face = $lc->get_intersection;		
	}
	return \@face;
}


#usage: localZetaFunction($diagram)
#computes the local zeta function
#for now only works for simplicial, because otherwise I need to do something more intelligent to compute the dim of a face
sub localZetaFunction{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $poly = newtonPolyhedron($diagram);
	my $bflist = boundedFaceList($poly, $diagram);
	my $fan = fan::normal_fan($poly);
	my $conehash = coneHash($diagram, $bflist, $fan);
	#pArrArr $conehash;
	my $zeta = new UniPolynomial("0");
	my @rays = @{$fan->RAYS};
	my @cones = @{allConesByDim($fan)};
	#my @allcones = @{allCones($fan)};			
	my $factor = new UniPolynomial "x/(x + 1)";
	#cdim + 1 = dimension of cone
	#dimension of facet = dim - cdim - 1
	for my $cdim (0..($dim - 1)){
		for my $cone (@{$cones[$cdim]}){
			my @theserays = map(\@{$rays[$_]}, @{$cone});
			my $face = coneToFace($conehash, \@{$cone});
			pArr $cone;
			pArr $face;
			print "\n";
			my $num = scalar(@{$face});
			#non-compact faces
			if ((scalar(@{$face}))!= ($dim - $cdim)){
				next;
			}
			if ($num == 1){
				$zeta = $zeta + totalContribution(\@theserays, $diagram);
			}
			if ($num > 1){
				my $contrib = totalContribution(\@theserays, $diagram);
				my $dim = scalar(@{$face}) - 1;
				my @verts = map($diagram->[$_], @{$face});
				my $coef = powMinusOne($dim)*normalizedVolume(\@verts);
				$zeta = $zeta + $factor*$coef*$contrib;
			}
		}
	}
	return $zeta;
}

#usage: isPole($rational function, $point)
#returns 1 if it is a pole 
#returns 0 if it is not a pole
sub isPole{
	my $rational = shift;
	my $point = shift;
	my $denom = denominator($rational);
	my $ans = $denom->evaluate($point);
	if (abs($ans) < 0.00000001){
		return 1;
	}
	return 0;
}




