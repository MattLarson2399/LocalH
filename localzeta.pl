#!/usr/bin/perl
#Contributors: Matt Larson
#Last updated: 12/05/2019

#computes the topological local zeta function associated to a Newton polyhedron

use strict;
use warnings;
use application "polytope";
use PDL;
use Algorithm::Combinatorics "subsets";
#use Math::Matrix;

script("/Users/matthew/Desktop/Local_Zeta_Function/code/subs.pl");

#usage: multiplicityArray(AoA)
#computes the multiplicity of an array of r integer vectors
#i.e. computes the index of the lattice generated by the vectors in the group of all lattice points 
#in the vector space spanned by the vectors
#does this by taking the gcd of the determinents of the rxr minors
sub multiplicityArray{
	my @input = @{shift @_};
	my @vecs = map(latticePointToArray($_), @input);
	my $num = scalar(@vecs);
	my @minors = subsets([0..scalar(@{$vecs[0]})-1], $num);
	#constructs matrix 
	my @matrixAoa = ();
	for my $i(0..($num - 1)){
		my @row = ();
		for my $j (0..($num - 1)){
			push(@row, $vecs[$i]->[$j]);
		}
		push(@matrixAoa, \@row);
	}
	my $a = pdl[\@matrixAoa];
	my $d = det($a);
	my $gcd;
	if ($d == 0){
		$gcd = 0;
	}
	else{
		#adds 0.1 to deal with numerical imprecision
		$gcd = new Integer (abs(($d->list)[0]) + 0.1);
	}
	for my $sub(@minors){
		@matrixAoa = ();
		for my $i(0..($num - 1)){
			my @row = ();
			for my $j (0..($num - 1)){
				push(@row, $vecs[$i]->[$sub->[$j]]);
			}
			push(@matrixAoa, \@row);
		}
		$a = pdl[\@matrixAoa];
		my $d = det($a);
		if ($d == 0){
			next;
		}
		else{
			my $toint = new Integer(abs((det($a)->list)[0]) + 0.1);
			$gcd = gcd($gcd, $toint);
		}
		if ($gcd == 1){
			last;
		}
	}
	return $gcd;
}

#usage: newtonPolyhedron($diagram)
#diagram does not need to be reduced
#outputs the newton polyhedron as a polyhedron
sub newtonPolyhedron{
	my $diagram = shift;
	my $proj = toReverseProjectiveArray($diagram);
	my $dim = scalar(@{$diagram->[0]});
	my $verts = standard_simplex_vertices($dim - 1);
	map(unshift($_, 0), @{$verts});
	push(@{$proj}, @{$verts});
	my $Mat=new Matrix<Rational>($proj);
	my $p = new Polytope(POINTS=>$Mat);
	return $p;
}

#usage: dualFan($diagram)
#creates the dual fan by making the newton polyhedron
sub dualFan{
	my $diagram = shift;
	my $newton = newtonPolyhedron($diagram);
	my $fan = fan::normal_fan($newton);
	return $fan;
}

#usage: changeToPrimitive($arref)
#assumes every entry is either 1 or 0 or a non-integer Rational - must use the polymake type
#returns a primitive integer vector in that direction
sub changeToPrimitive{
	my @array = @{shift @_};
	#@array = map(vectorToArray($_), @array);
	my $denom = 1;
	for my $n (@array){
		if (($n == 0) or ($n == 1)){
			next;
		}
		$denom = denominator($n) * $denom;
	}
	my @result;
	for my $n (@array){
		my $a = new Integer($n * $denom);
		push(@result, $a);
	}
	return makePrimitive(\@result);
}

#usage:dotProduct($aref, $aref)
#arefs should be the same length
#computes the dot product
sub dotProduct{
	my $vec1 = shift;
	my $vec2 = shift;
	my $answer = 0;
	for my $i (0..(scalar(@{$vec1}) - 1)){
		$answer += ($vec1->[$i])*($vec2->[$i]);
	}
	return $answer;
}


#usage: computeN($point, $diagram)
#takes a point in the dual fan
#compute the minimimum value of the pairing of that with the newton polyhedron
sub computeN{
	my $point = shift;
	my $diagram = shift;
	my $best = dotProduct($point, $diagram->[0]);
	for my $i (0..(scalar(@{$diagram}) - 1)){
		if ($best > dotProduct($point, $diagram->[$i])){
			$best = dotProduct($point, $diagram->[$i]);
		}
	}
	return $best;
}

#usage: jDelta(arref of points, diagram)
#computes J_{\Delta} for the cone spanned by these points
#points should be primitive, but will make sense if not
sub jDelta{
	my @points = @{shift @_};
	my $diagram = shift;
	my $mult = multiplicityArray(\@points);
	#my $mult = 1;
	my $answer = new UniPolynomial($mult);
	for my $p (@points){
		my $n = computeN($p, $diagram);
		my $v = sumArray($p);
		my $contrib = new UniPolynomial("$n*x + $v");
		$answer = $answer/$contrib
	}
	return $answer;
}

#usage: normalizedVolume($arref of lattice points)
#returns the normalized volume of the convex hull of the vertices
sub normalizedVolume{
	my $vertices = shift;
	my $proj = toReverseProjectiveArray($vertices);
	my $poly = new LatticePolytope(POINTS=>$proj);
	return $poly->LATTICE_VOLUME;

}

#usage: subdivideCone(arref of vertices)
#returns a subdivision of the cone by the convex hull of the vertices 
sub subdivideCone{
	my @rays = @{shift @_};
	my $cone = new Cone(RAYS=>\@rays);
	my $t = $cone->TRIANGULATION;
	my $vectorsubdiv = $t->FACETS;
	my @subdiv = map(vectorToArray($_), @{$vectorsubdiv});
	return \@subdiv;
}

#usage: totalContribution(rays of a cone, diagram)
#subdivides the cone into rational simplicial parts and returns the total contribution
sub totalContribution{
	my $rays = shift;
	my $diagram = shift;
	my $primitive = subdivideCone($rays);
	my $answer = new UniPolynomial("0");
	for my $tri (@{$primitive}){
		my @subdividedrays = map($rays->[$_], @{$tri});
		my @prim = map(changeToPrimitive($_), @subdividedrays);
		$answer = $answer + jDelta(\@prim, $diagram);
	}
	return $answer;
}


#usage: allCones(Fan)
#returns all cones of the fan
#includes the empty cone
sub allCones{
	my $fan = shift;
	my @cones = @{$fan->MAXIMAL_CONES};
	my @allcones;
	my %hash;	
	for my $cone (@cones){
		my @c = @{$cone};
		my @subcones = subsets(\@c);
		for my $sc (@subcones){
			my $str = "@{$sc}";
			if (not $hash{$str}){
				$hash{$str} = 1;
				push(@allcones, $sc);
			}
		}
	}
	return \@allcones;
}


#usage: allConesByDim($fan)
#returns an Array of Array of Arrays
#first array is the dimension of the cone
#second AoA contains all cones of that dimension
sub allConesByDim{
	my $fan = shift;
	my @cones = @{$fan->CONES};
	my @results;
	for my $i (0..(($fan->DIM) - 1)){
		my @cdims = map(vectorToArray($_), @{$cones[$i]});
		push(@results, \@cdims);
	}
	return \@results;
}

#usage: rayToFacet(ray, diagram, sorted AoA of bounded facets)
#the AoA must be a sorted (by decreasing length) array of the bounded faces of the newton polyhedron 
#facet should be given as a list of vertices in the diagram, diagram should be reduced
#returns the facet corresponding to the array
#does this by looping through the facets, checking if the pairing of ray with all vertices in them is the same
#if it doesn't match any of them then returns -1
sub rayToFacet{
	my @ray = @{shift @_};
	my $diagram = shift;
	my @flist = @{shift @_};
	my $correct = 1;
	my $num = computeN(\@ray, $diagram);
	for my $f (@flist){
		$correct = 1;
		for my $i (0..(scalar(@{$f}) - 1)){
			if ($num != dotProduct(\@ray, $diagram->[$f->[$i]])){
				$correct = 0;
				last;
			}
		}
		if ($correct == 1){
			return $f;
		}

	}
	return -1;
}

#usage: boundedPart(face, diagram)
#returns the maximal bounded face contained in the face
#diagram must be reduced
sub boundedPart{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @new_face;
	for my $v (@face){
		if ($v < $num_verts){
			push(@new_face, $v);
		}
	}
	return \@new_face;
}

#usage: isBounded($face, $diagram)
#returns 1 if the face is bounded, 0 if it is not
sub isBounded{
	my @face = @{shift @_};
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	for my $v (@face){
		if ($v >= $num_verts){
			return 0;
		}
	}
	return 1;
}

#usage: facetsList{$newtonPoly}
#returns an AoA of the facets, 
sub facetList{
	my $poly = shift;
	my @flist = @{$poly->VERTICES_IN_FACETS};
	my @result = map(vectorToArray($_), @flist);
	return \@result;
}

#usage:coneHash($diagram, $faceList, $dualFan)
#returns the faces in the order of the rays
#doesn't actually return a hash
#doesn't work
sub badConeHash{
	my $diagram = shift;
	my $facelist = shift;
	my $dualFan = shift;
	my @rays = map(vectorToArray($_), @{$dualFan->RAYS});
	my @faces = map(rayToFacet($_, $diagram, $facelist), @rays);
	return \@faces;
}

#usage: coneHash($facetlist, $diagram)
#diagram must be reduced
#creates a ray - to - facet correspondence by taking the facets of the newton polyhedron, removing the far face
sub coneHash{
	my $flist = shift;
	my $diagram = shift;
	my $num_verts = scalar(@{$diagram});
	my @good;
	for my $f (@{$flist}){
		if ($f->[0] < $num_verts){
			push(@good, $f)
		}
	}
	return \@good;
}



#usage: coneToFace(list of bounded faces corresponding to each ray, $cone)
#returns arref of the corresponding face
sub coneToFace{
	my $conehash = shift;
	my $cone = shift;
	if (scalar(@$cone == 1)){
		return $conehash->[$cone->[0]];
	}
	my $lc = List::Compare->new(map($conehash->[$_], @{$cone}));
	my @answer = $lc->get_intersection;
	return \@answer;
}

#usage: findFace(cone, diagram)
#takes a cone in the dual cone, returns the face in the newton polyhedron that it corresponds to
#input cone as an array of spanning vertices 
#they should actually be a non-empty cone in the dual fan
#returns the indices of the vertices
#doesn't work
sub findFace{
	my @cone = @{shift @_};
	my $diagram = shift;
	my $n = computeN($cone[0], $diagram);
	my @face;
	for my $vertex (0..(scalar(@{$diagram}) - 1)){
		if (dotProduct($diagram->[$vertex], $cone[0]) == $n){

			push(@face, $vertex);
		}		
	}
	for my $index (1..(scalar(@cone) - 1)){
		$n = computeN($cone[$index], $diagram);
		my @face2;
		for my $vertex (0..(scalar(@{$diagram}) - 1)){
			if (dotProduct($diagram->[$vertex], $cone[$index]) == $n){
				push(@face2, $vertex);
			}
		}
		my $lc = List::Compare->new(\@face, \@face2);
		@face = $lc->get_intersection;		
	}
	return \@face;
}


#usage: localZetaFunction($diagram)
#computes the local zeta function
#for now only works for simplicial, because otherwise I need to do something more intelligent to compute the dim of a face
#diagram must be reduced
sub localZetaFunction{
	my $diagram = shift;
	my $dim = scalar(@{$diagram->[0]});
	my $poly = newtonPolyhedron($diagram);
	my $facetList = facetList($poly, $diagram);
	my $fan = fan::normal_fan($poly);
	my $conehash = coneHash($facetList, $diagram);

	my $zeta = new UniPolynomial("0");
	my @rays = @{$fan->RAYS};
	my @cones = @{allConesByDim($fan)};
	my $factor = new UniPolynomial "x/(x + 1)";
	#cdim + 1 = dimension of cone
	#dimension of face = dim - cdim - 1
	for my $cdim (0..($dim - 1)){
		for my $cone (@{$cones[$cdim]}){
			my @theserays = map(\@{$rays[$_]}, @{$cone});
			my $face = coneToFace($conehash, \@{$cone});
			#cones corresponding to non-compact faces
			if (isBounded($face, $diagram) == 0){
				next;
			}

			my $num = scalar(@{$face});

			if ($num == 1){
				$zeta = $zeta + totalContribution(\@theserays, $diagram);
			}
			if ($num > 1){
				my $contrib = totalContribution(\@theserays, $diagram);
				my $fdim = $dim - $cdim - 1;
				my @verts = map($diagram->[$_], @{$face});
				my $coef = powMinusOne($fdim)*normalizedVolume(\@verts);
				$zeta = $zeta + $factor*$coef*$contrib;
			}
		}
	}
	return $zeta;
}

#usage: isPole($rational function, $point)
#returns 1 if it is a pole 
#returns 0 if it is not a pole
sub isPole{
	my $rational = shift;
	my $p = shift;
	my $point = new Rational($p);
	my $denom = denominator($rational);
	my $ans = $denom->evaluate($point);
	if ($ans == 0){
		return 1;
	}
	return 0;
}

#usage: allContributingFacets($diagram, $list of facets, $number)
#returns an array with a list of all facets that contribute that number
#diagram must be reduced
#checks if it is within 10^{-5}
sub allContributingFacets{
	my $diagram = shift;
	my $flist = shift;
	my $num = shift;
	my @facets;
	for my $f(@{$flist}){
		if ((abs(candidatePole($diagram, \@{$f}) - $num) < 0.00001)){
			push(@facets, \@{$f});
		}
	}
	return \@facets; 
}

#usage:checkAllForCounterexample($diagram)
#diagramn must be reduced
#checks every pole if it gives a counterexample
#checks if there is a facet with essential face contributing
sub checkAllForCounterexample{
	my $diagram = shift;
	my $subdiv = nonSimpDiagramToSimp($diagram);
	my $flist = $subdiv->FACETS;
	my $list = allCandidatePoles($diagram);
	my $localzeta = localZetaFunction($diagram);
	my $good = 0;
	for my $num (@{$list}){
		$good = 0;
		if (isPole($localzeta, $num)){
			my $facets = allContributingFacets($diagram, $flist, $num);
			for my $f (@{$facets}){
				if (computeMultiplicity($diagram, $f) > 0){
					$good = 1;
					last;
				}
			}
			if ($good == 0){
				print "Found counterexample";
			return 1;
			}
		}

	}
	return 0;	
}

#usage: quicklyTestDiagram($diagram)
#diagram need not be reduced
#tests topological monodromy conjecture
#does not use any results about when B_1 facets don't give rise to candidate poles
#checks for each pole if there is a B_1 facet that contributes that eigenvalue, there could be other facets
sub quicklyTestDiagram{
	my $diagram = shift;
	$diagram = completelyReduceDiagram($diagram);
	my $subdiv = nonSimpDiagramToSimp($diagram);
	my $perturbed = diagramToPerturbedSubdiv($diagram);
	#finds the universally B_1 facets and B_1 facet
	my @tocheck;
	my @flist = @{$subdiv->FACETS};
	for my $f (@flist){
		my @facet = @{$f};
		if (isB1Facet($diagram, \@facet)){
			push(@tocheck, \@facet);
			next;
		}
		if (noGoodTriangulation($diagram, \@facet)){
			push(@tocheck, \@facet);
		}

	}
	if (scalar(@tocheck) == 0){
		return 0;
	}
	my $localzeta = localZetaFunction($diagram);
	#creates list of real poles that are contribute by (universally) B_1 facets
	my @allcandidates;
	for my $f (@tocheck){
		my @f = @{$f};
		my $tri = findTriangulated($diagram, $perturbed, \@f)->[0];
		push(@allcandidates, candidatePole($diagram, $tri));
	}
	#checks if these candidates are actually poles
	my @poleslist;
	for my $pole (@allcandidates){
		if (canonicalMod1($pole) < 0.0000001){
			next;
		}
		if (abs(canonicalMod1($pole) - 1) < 0.0000001){
			next;
		}
		if (isPole($localzeta, $pole)){
			push(@poleslist, $pole);
		}
	}
	if(scalar(@poleslist) == 0){
		return 0;
	}
	#loops through all facets, checks if their candidate pole is one of the poles 
	#if it is, computes contribution 
	#if contribution is positive, removes corresponding poles
	pArr(\@poleslist);
	for my $f (@flist){
		if (scalar(@{poleslist}) == 0){
			return 0;
		}
		my @facet = @{$f};

		my $tri = findTriangulated($diagram, $perturbed, \@facet)->[0];
		my $num = exactCandidatePole($diagram, $tri);
		my @matching_indices;
		for my $i (0..(scalar(@{poleslist}) - 1)){
			if (abs($num - $poleslist[$i]) < 0.000001){
				push(@matching_indices, $i);
			}
		}
		if (computeMultiplicity($diagram, \@facet) == 0){
			next;
		}
		#removes the matching indices
		my $total = scalar(@matching_indices);
		for my $i (0..($total - 1)){
			splice(@poleslist, ($total - 1 - $i), 1);
		}
		pArr(\@poleslist);
	}
	if (scalar(@poleslist) == 0){
		return 0;
	}
	print "Found counterexample";
	return 1;

}

#usage: exactCandidatePole($diagram, $facet)
#diagram should be completely reduced 
#facet should be an actual facet 
#returns the candidate pole as a rational number
sub exactCandidatePole{
	my $diagram = shift;
	my $poly = newtonPolyhedron($diagram);
	my $facet = shift;
	my @facets = @{$p->VERTICES_IN_FACETS};
	for my $index (0..(scalar(@facets) - 1)){
		my $f = $facets[$index];
		for my $i (0..(scalar(@{$facet}) - 1)){
			if ($facet->[$i] != $f->[$i]){
				last;
			}
			if ($i == (scalar(@{$facet}) - 1)){
				my @normal = @{$poly->FACETS->[$index]};
				shift(@normal);
				my $normalized = new Vector(\@normal);
				my $nu = sumArray(\@{$normalized});
				my $N = 0;
				for my $j (0..(scalar(@normal) - 1)){
					$N += ($diagram->[$facet->[0]]->[$j])*($normalized->[$j]);
				}
				my $answer = new Rational(-$nu/$N);
				return $answer;
			}
		}
	}
}























